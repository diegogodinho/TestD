@{
    ViewData["Title"] = "Home Page";
}
<div class="text-center">
    <h1 class="display-4">Welcome</h1>
</div>
<p><h3>Instructions for the test: </h3></p>
<p>There are two logins available:</p>
<p>Username: <b>user</b> Password:<b>123</b></p>
<p>Username: <b>admin</b> Password:<b>123</b></p>
<p><h3>Design Choices: </h3></p>
<p> Application Built Using <b>.Net Core 2.2 MVC, BootsTrap 4</b> and <b>Jquery</b></p>
<p>
    The application uses dependency injection built in on the .Net Core, allowing the Application to have a loose coupling between the layers.
</p>
<p>
    I've used Domain-Driven Design as an approach.
</p>
<p>
    The application has 4 Layers.
</p>
<p>
    The Web Layer is responsible for handling all requests, screen validations and objects conversions (Using Automapper).
</p>
<p>
    The Domain layer is responsible to hold all the business objects, this layer is known for all other layers.
</p>
<p>
    The Service Layer is responsible for all the business logic/ business validations, and call the correct repository to store the information.
</p>
<p>
    The Repository has the responsibility to manage queries and store data on my repository. I'm using EntityframeworkCore to store the data in memory, Code first approach. 
    I thought it would be easier to use the Code First approach as I'm storing information in memory.
</p>
<p>
    In this case scenario, most of the time the Service Layer works as a Wrapper between the Web Layer and The repository.
</p>
<p>
    As you can see all layers have their own dependencies that cannot be shared between them, e.g. only the repository knows the EntityFrameworkCore DLL. 
    This way we can have a loose coupling between layers, making the App flexible for further changes.
</p>
<p>
    I could've have used Angular 7 and Core API for this test, but unfortunately, I didn't have enough time to implement it. 
    I would have used tokens for authentication instead of cookies.
</p>

